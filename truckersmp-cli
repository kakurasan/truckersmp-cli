#!/usr/bin/env python3

import argparse
import distutils.spawn
from gettext import ngettext
import hashlib
import http.client
import io
from json import JSONDecoder
import locale
import os
import signal
import subprocess as subproc
import sys
import tarfile
import time
import urllib.request


class URL:
    """ URLs """
    dlurl = "download.ets2mp.com"
    dlurlalt = "downloads.ets2mp.com"
    listurl = "https://update.ets2mp.com/files.json"
    issueurl = "https://github.com/lhark/truckersmp-cli/issues"
    steamcmdurl = "\
https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz"


class AppId:
    """ steam AppIds """
    game = {
        "ats":          270880,        # https://steamdb.info/app/270880/
        "ets2":         227300,        # https://steamdb.info/app/227300/
    }
    proton = {
        "4.2":          1054830,       # https://steamdb.info/app/1054830/
        "3.16 Beta":    996510,        # https://steamdb.info/app/996510/
        "3.16":         961940,        # https://steamdb.info/app/961940/
        "3.7 Beta":     930400,        # https://steamdb.info/app/930400/
        "3.7":          858280,        # https://steamdb.info/app/858280/
    }
    default_proton_ver = "4.2"


class Dir:
    """ directories """
    XDG_CACHE_HOME = os.getenv(
      "XDG_CACHE_HOME", os.path.join(os.path.expanduser("~"), ".cache"))
    XDG_DATA_HOME = os.getenv(
      "XDG_DATA_HOME", os.path.join(os.path.expanduser("~"), ".local/share"))
    default_gamedir = {
        "ats": os.path.join(
          XDG_DATA_HOME, "truckersmp-cli/American Truck Simulator/data"),
        "ets2": os.path.join(
          XDG_DATA_HOME, "truckersmp-cli/Euro Truck Simulator 2/data"),
    }
    default_prefixdir = {
        "ats": os.path.join(
          XDG_DATA_HOME, "truckersmp-cli/American Truck Simulator/prefix"),
        "ets2": os.path.join(
          XDG_DATA_HOME, "truckersmp-cli/Euro Truck Simulator 2/prefix"),
    }
    default_moddir = os.path.join(XDG_DATA_HOME, "truckersmp-cli/TruckersMP")
    default_protondir = os.path.join(XDG_DATA_HOME, "truckersmp-cli/Proton")
    scriptdir = os.path.dirname(os.path.realpath(__file__))
    steamcmddir = os.path.join(XDG_CACHE_HOME, "truckersmp-cli/steamcmd")


def printdbg(msg, end="\n"):
    if args.verbose:
        print(msg, end=end)


def printerr(msg, end="\n"):
    print(msg, end=end, file=sys.stderr)


def download_files(host, files_to_download):
    try:
        conn = http.client.HTTPSConnection(host)
    except Exception as e:
        printerr("Failed to connect to {}: {}".format(host, e))
        return False
    try:
        while len(files_to_download) > 0:
            path, dest, md5 = files_to_download[0]
            md5hash = hashlib.md5()
            bufsize = md5hash.block_size * 256
            name = os.path.basename(path)
            destdir = os.path.dirname(dest)
            printdbg(
              "Downloading file https://{}{} to {}".format(
               host, path, destdir))

            # make file hierarchy
            os.makedirs(destdir, exist_ok=True)

            # download file
            conn.request("GET", path, headers={"Connection": "keep-alive"})
            res = conn.getresponse()

            if res.status != 200:
                printerr("Server response code is not 200.")
                return False

            lastmod = res.getheader("Last-Modified")
            content_len = res.getheader("Content-Length")

            with open(dest, "wb") as f:
                downloaded = 0
                while True:
                    buf = res.read(bufsize)
                    if not buf:
                        break
                    downloaded += len(buf)
                    f.write(buf)
                    md5hash.update(buf)
                    if content_len:
                        progress = "{:,} / {:,}".format(
                          downloaded, int(content_len))
                    else:
                        progress = "{:,}".format(downloaded)
                    print("\r{:40}{:>40}".format(name, progress), end="")

            if md5hash.hexdigest() != md5:
                print("\r{:40}{:>40}".format(name, "MD5 ERROR"))
                printerr("MD5 mismatch for {}".format(dest))
                return False

            # wget-like timestamping for downloaded files
            if lastmod:
                timestamp = time.mktime(
                  time.strptime(
                   lastmod, "%a, %d %b %Y %H:%M:%S GMT")) - time.timezone
                try:
                    os.utime(dest, (timestamp, timestamp))
                except Exception:
                    pass

            # downloaded successfully
            print("\r{:40}{:>40}".format(name, "OK"))

            # skip already downloaded files
            # when trying to download from URL.dlurlalt
            del files_to_download[0]
    except Exception as e:
        printerr("Failed to download https://{}{}: {}".format(host, path, e))
        return False
    finally:
        conn.close()

    return True


def start_with_proton():
    steamdir = None
    # "steam" command in Debian package uses ~/.steam as steam user directory
    # instead of $XDG_DATA_HOME/Steam
    try:
        with open("/usr/games/steam") as f:
            for l in f:
                if l.rstrip() == "config=$HOME/.steam":
                    steamdir = os.path.join(os.path.expanduser("~"), ".steam")
                    break
    except Exception:
        pass
    if not steamdir:
        steamdir = os.path.join(Dir.XDG_DATA_HOME, "Steam")

    # make sure steam is started
    # It's probably safe to assume steam is up and running completely started
    # when the user is logged in. On user login the timestamp in
    # [steam user directory]/config/loginusers.vdf gets updated.
    # We can detect the timestamp update with inotifywait -e modify.
    # Needs inotify-tools installed
    try:
        subproc.check_call(["pidof", "steam"], stdout=subproc.DEVNULL)
    except Exception:
        printdbg("Starting Steamâ€¦")
        subproc.Popen(
          ["nohup", "steam"],
          stdout=subproc.DEVNULL, stderr=subproc.STDOUT)

        # wait for user login
        try:
            if not distutils.spawn.find_executable("inotifywait"):
                printerr("Inotify-tools not installed.")
                raise Exception

            printdbg("Waiting for Steam using inotifywait.")
            loginusers_vdf = os.path.join(steamdir, "config/loginusers.vdf")
            if os.path.isfile(loginusers_vdf):
                subproc.call(
                  ["inotifywait", "-e", "modify", "-qq", loginusers_vdf])
                printdbg(
                  "Steam should now be up and running and the user logged in.")
            else:
                printerr("{} is not present.".format(loginusers_vdf))
                raise Exception
        except Exception:
            # fallback to 30 seconds if inotify-tools is not installed
            # or config/loginusers.vdf is not present
            # Maybe enhance this with manual timestamp comparison
            # in the future.
            waittime = 30
            while waittime > 0:
                printerr(
                  ngettext(
                   "\rWaiting {} second for steam to start up. ",
                   "\rWaiting {} seconds for steam to start up. ",
                   waittime).format(waittime), end="")
                time.sleep(1)
                waittime -= 1
            printerr("")  # newline
            printdbg("Steam should be up now")

    if os.path.isdir(args.prefixdir):
        printdbg("Creating directory {}".format(args.prefixdir))
        os.makedirs(args.prefixdir, exist_ok=True)

    env = {
        "SteamGameId": args.steamid,
        "SteamAppId": args.steamid,
        "STEAM_COMPAT_DATA_PATH": args.prefixdir,
        "STEAM_COMPAT_CLIENT_INSTALL_PATH": steamdir,
    }
    for key, value in env.items():
        os.environ[key] = value
    proton = os.path.join(args.protondir, "proton")
    tmpcliexe = os.path.join(Dir.scriptdir, "truckersmp-cli.exe")
    printdbg("""Startup command:
  SteamGameId={}
  SteamAppId={}
  STEAM_COMPAT_DATA_PATH={}
  STEAM_COMPAT_CLIENT_INSTALL_PATH={}
  {} {}
  run
  {} {} {}""".format(
      env["SteamGameId"], env["SteamAppId"],
      env["STEAM_COMPAT_DATA_PATH"], env["STEAM_COMPAT_CLIENT_INSTALL_PATH"],
      sys.executable, proton, tmpcliexe, args.gamedir, args.moddir))
    subproc.call(
      [sys.executable, proton, "run", tmpcliexe, args.gamedir, args.moddir])


def start_with_wine():
    print("""
    ###################################################################
    #                                                                 #
    #  Please check wine steam is running or the launcher won't work  #
    #                                                                 #
    ###################################################################

    Press enter if you are good to go: """, end="")
    sys.stdin.readline()

    env = {
        "WINEDEBUG": "-all",
        "WINEARCH": "win64",
        "WINEPREFIX": args.prefixdir,
    }
    for key, value in env.items():
        os.environ[key] = value
    tmpcliexe = os.path.join(Dir.scriptdir, "truckersmp-cli.exe")
    printdbg("""Startup command:
  WINEDEBUG=-all
  WINEARCH=win64
  WINEPREFIX={}
  wine {} {} {}""".format(
      env["WINEPREFIX"], tmpcliexe, args.gamedir, args.moddir))
    subproc.call(["wine", tmpcliexe, args.gamedir, args.moddir])


# download missing or outdated files
def update_mod():
    # update the script itself when origin/master is checked out
    try:
        out = subproc.check_output(
          ["git", "-C", Dir.scriptdir,
           "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"])
        if out == "origin/master":
            printdbg(
              "This script is checked out with git, upstream is origin/master")
            printdbg("Running git pull")
            subproc.check_call(
              ["git", "-C", Dir.scriptdir, "pull"],
              stdout=subproc.DEVNULL, stderr=subproc.STDOUT)
        else:
            raise Exception
    except Exception:
        printdbg("Better do not self update")

    if not os.path.isdir(args.moddir):
        printdbg("Creating directory {}".format(args.moddir))
        os.makedirs(args.moddir, exist_ok=True)

    # get the fileinfo from the server
    try:
        with urllib.request.urlopen(URL.listurl) as f:
            files_json = f.read()
    except Exception as e:
        sys.exit("Failed to download files.json: {}".format(e))

    # extract md5sums and filenames
    modfiles = []
    try:
        for item in JSONDecoder().decode(str(files_json, "ascii"))["Files"]:
            modfiles.append((item["Md5"], item["FilePath"]))
        if len(modfiles) == 0:
            raise Exception("File list is empty")
    except Exception as e:
        sys.exit("""Failed to parse files.json: {}
Please report an issue: {}""".format(e, URL.issueurl))

    # compare existing local files with md5sums
    # and remember missing/wrong files
    dlfiles = []
    for md5, jsonfilepath in modfiles:
        md5hash = hashlib.md5()
        modfilepath = os.path.join(args.moddir, jsonfilepath[1:])
        if not os.path.isfile(modfilepath):
            dlfiles.append(("/files" + jsonfilepath, modfilepath, md5))
        else:
            try:
                with open(modfilepath, "rb") as f:
                    while True:
                        buf = f.read(md5hash.block_size * 4096)
                        if not buf:
                            break
                        md5hash.update(buf)
                if md5hash.hexdigest() != md5:
                    dlfiles.append(("/files" + jsonfilepath, modfilepath, md5))
            except Exception as e:
                sys.exit("Failed to read {}: {}".format(modfilepath, e))
    if len(dlfiles) > 0:
        printdbg("Files to download:")
        for path, _, _ in dlfiles:
            printdbg("  {}".format(path))
    else:
        printdbg("No files to download")

    # download missing/wrong files
    if not download_files(URL.dlurl, dlfiles):
        if not download_files(URL.dlurlalt, dlfiles):
            # something went wrong
            sys.exit("Failed to download mod files.")


def update_game():
    # make sure steam is closed before updating
    # it's possible to update with the steam client open but the client looses
    # all connectivity and asks for password and steam guard code after restart
    while True:
        try:
            subproc.check_call(["pidof", "steam"], stdout=subproc.DEVNULL)
        except Exception:
            break
        else:
            printdbg("Found running steam, running pkill -x steam")
            subproc.call(["pkill", "-x", "steam"])
            time.sleep(5)

    if not os.path.isdir(args.gamedir):
        printdbg("Creating directory {}".format(args.gamedir))
        os.makedirs(args.gamedir, exist_ok=True)

    # fetch steamcmd if not in $PATH
    steamcmd = distutils.spawn.find_executable("steamcmd")
    if not steamcmd:
        printdbg("steamcmd not found in $PATH")
        steamcmd = os.path.join(Dir.steamcmddir, "steamcmd.sh")
        if not os.path.isfile(steamcmd):
            printdbg("Downloading steamcmd")
            os.makedirs(Dir.steamcmddir, exist_ok=True)
            try:
                with urllib.request.urlopen(URL.steamcmdurl) as f:
                    steamcmd_targz = f.read()
            except Exception as e:
                sys.exit("Failed to download steamcmd: {}".format(e))
            with tarfile.open(
              fileobj=io.BytesIO(steamcmd_targz), mode="r:gz") as f:
                f.extractall(Dir.steamcmddir)

    else:
        printdbg("steamcmd found in $PATH")
    printdbg("Steamcmd: {}".format(steamcmd))

    # download/update Proton
    if args.proton:
        printdbg("Updating Proton (AppId:{})".format(args.proton_appid))

        if not os.path.isdir(args.protondir):
            printdbg("Creating directory {}".format(args.protondir))
            os.makedirs(args.protondir, exist_ok=True)

        printdbg("""Command:
  {}
    +login {}
    +force_install_dir {}
    +app_update {} validate
    +quit""".format(steamcmd, args.account, args.protondir, args.proton_appid))
        subproc.call(
          [steamcmd,
           "+login", args.account,
           "+force_install_dir", args.protondir,
           "+app_update", str(args.proton_appid), "validate",
           "+quit"])

    # use steamcmd to update the chosen game
    printdbg("Updating Game (AppId:{})".format(args.steamid))
    printdbg("""Command:
  {}
    +@sSteamCmdForcePlatformType windows
    +login {}
    +force_install_dir {}
    +app_update {} validate
    +quit""".format(steamcmd, args.account, args.gamedir, args.steamid))
    subproc.call(
      [steamcmd,
       "+@sSteamCmdForcePlatformType", "windows",
       "+login", args.account,
       "+force_install_dir", args.gamedir,
       "+app_update", args.steamid, "validate",
       "+quit"])


def check_error():
    # checks for updating and/or starting
    if not args.update and not args.start:
        sys.exit("What to do? Starting (-s) or updating (-u) the game?")

    # make sure only one game is chosen
    if args.ats and args.ets2:
        sys.exit("It's only possible to use one game at a time.")
    elif not args.ats and not args.ets2:
        sys.exit("Need at least one game. ATS (-a) or ETS2 (-e)")

    game = "ats" if args.ats else "ets2"
    args.steamid = str(AppId.game[game])
    if not args.prefixdir:
        args.prefixdir = Dir.default_prefixdir[game]
    if not args.gamedir:
        args.gamedir = Dir.default_gamedir[game]

    # checks for starting
    if args.start:
        # make sure proton and wine aren't chosen at the same time
        if args.proton and args.wine:
            sys.exit("Start with Proton (-p) or Wine (-w)?")
        elif not args.proton and not args.wine:
            sys.exit("Only possible to start with Proton (-p) or Wine (-w).")

        # make sure proton and wine are using the same default
        if args.wine:
            if (args.prefixdir == Dir.default_prefixdir["ats"]
               or args.prefixdir == Dir.default_prefixdir["ets2"]):
                printdbg("""prefixdir is the default while using wine,
make sure it uses the same folder as proton""")
                args.prefixdir = os.path.join(args.prefixdir, "pfx")

    # checks for starting while not updating
    if args.start and not args.update:
        # check for game
        if (not os.path.isfile(
              os.path.join(args.gamedir, "bin/win_x64/eurotrucks2.exe"))
            and not os.path.isfile(
              os.path.join(args.gamedir, "bin/win_x64/amtrucks.exe"))):
            sys.exit("""Game not found in {}
Need to download (-u) the game?""".format(args.gamedir))

        # check for proton
        if (not os.path.isfile(os.path.join(args.protondir, "proton"))
           and args.proton):
            sys.exit("""Proton and no update wanted but Proton not found in {}
Need to download (-u) Proton?""".format(args.protondir))

    # checks for updating
    if args.update:
        if not args.account:
            sys.exit("Need the steam account name (-n name) to update.")

    # debug
    printdbg("AppId/GameId: {}".format(args.steamid))
    printdbg("Game directory: {}".format(args.gamedir))
    printdbg("Prefix: {}".format(args.prefixdir))
    if args.proton:
        printdbg("Proton directory: {}".format(args.protondir))


def create_arg_parser():
    desc = """
truckersmp-cli is an easy to use script to download TruckersMP and start the
game afterwards.
It can install and update the windows version of
American Truck Simulator (-a) or Euro Truck Simulator 2 (-e)
with steamcmd (-u) and handles starting (-s) the mod through Proton aka.
Steam Play (-p) or Wine (-w).
It needs a working Steam installation in $XDG_DATA_HOME/Steam for starting
through Proton or to update the game files. It will
stop all running Steam processes while updating to prevent Steam asking
for password and guard code at the next startup.
When using standard Wine you should start the windows version of Steam first.
"""
    epilog = "Proton AppId list:\n"
    for k, v in AppId.proton.items():
        default_mark = " (Default)" if k == AppId.default_proton_ver else ""
        epilog += "    Proton {:13}: {:>10}{}\n".format(k, v, default_mark)
    epilog += """See https://github.com/ValveSoftware/Proton/issues/162
if you want to use a lower version than 3.16 Beta."""
    ap = argparse.ArgumentParser(
      description=desc, epilog=epilog,
      formatter_class=argparse.RawDescriptionHelpFormatter)
    ap.add_argument(
      "-a", "--ats",
      help="use American Truck Simulator", action="store_true")
    ap.add_argument(
      "-e", "--ets2",
      help="use Euro Truck Simulator 2", action="store_true")
    ap.add_argument(
      "-p", "--proton",
      help="start the game with Proton", action="store_true")
    ap.add_argument(
      "-w", "--wine",
      help="start the game with Wine", action="store_true")
    ap.add_argument(
      "-s", "--start",
      help="start the game", action="store_true")
    ap.add_argument(
      "-u", "--update",
      help="update the game", action="store_true")
    ap.add_argument(
      "-v", "--verbose",
      help="verbose", action="store_true")
    ap.add_argument(
      "-g", "--gamedir", metavar="DIR", type=str,
      help="""choose a different directory for the game files
              [Default: $XDG_DATA_HOME/truckersmp-cli/(Game name)/data]""")
    ap.add_argument(
      "-i", "--proton-appid", metavar="APPID", type=int,
      default=AppId.proton[AppId.default_proton_ver],
      help="choose a different AppId for Proton (Needs an update for changes)")
    ap.add_argument(
      "-m", "--moddir", metavar="DIR", type=str,
      help="""choose a different directory for the mod files
              [Default: $XDG_DATA_HOME/truckersmp-cli/TruckersMP,
              Fallback: ./truckersmp]""")
    ap.add_argument(
      "-n", "--account", metavar="NAME", type=str,
      help="""steam account name to use
              (This account should own the game and ideally is logged in
              with saved credentials)""")
    ap.add_argument(
      "-o", "--protondir", metavar="DIR", type=str,
      default=Dir.default_protondir,
      help="""choose a different Proton directory
              [Default: $XDG_DATA_HOME/truckersmp-cli/Proton]
              While updating any previous version in this folder gets changed
              to the given (-i) or default Proton version""")
    ap.add_argument(
      "-x", "--prefixdir", metavar="DIR", type=str,
      help="""choose a different directory for the prefix
              [Default: $XDG_DATA_HOME/truckersmp-cli/(Game name)/prefix]""")

    return ap


if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    locale.setlocale(locale.LC_MESSAGES, "")
    locale.setlocale(locale.LC_TIME, "C")

    # parse options
    args = create_arg_parser().parse_args()

    # fallback to old local folder
    if not args.moddir:
        if os.path.isdir(os.path.join(Dir.scriptdir, "truckersmp")):
            printdbg("No moddir set and fallback found")
            args.moddir = os.path.join(Dir.scriptdir, "truckersmp")
        else:
            printdbg("No moddir set, setting to default")
            args.moddir = Dir.default_moddir
    printdbg("Mod directory: {}".format(args.moddir))

    # check for errors
    check_error()

    # download/update ATS/ETS2 and Proton
    if args.update:
        printdbg("Updating game files")
        update_game()

    # always update truckersmp
    printdbg("Updating mod files")
    update_mod()

    # start truckersmp with proton or wine
    if args.start:
        printdbg("Starting game with ", end="")
        if args.proton:
            printdbg("Proton")
            start_with_proton()
        elif args.wine:
            printdbg("Wine")
            start_with_wine()

    sys.exit()
